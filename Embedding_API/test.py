import requests
import json

# URL твоего API
BASE_URL = "http://localhost:8000"

# Тестовый текст (можно заменить на свой)
test_text = """
Машинное обучение — это раздел искусственного интеллекта, изучающий методы построения алгоритмов, способных обучаться.

Нейронные сети представляют собой вычислительные системы, вдохновлённые биологическими нейронными сетями. Они состоят из множества взаимосвязанных узлов (нейронов), организованных в слои.

Векторные представления текста, или эмбеддинги, позволяют представить слова и предложения в виде векторов чисел. Это ключевая технология в обработке естественного языка.

Трансформеры революционизировали область NLP. Архитектура трансформера основана на механизме внимания (attention), который позволяет модели фокусироваться на наиболее важных частях входных данных.
"""

def test_health():
    """Проверка здоровья API"""
    print("=== Тест /health ===")
    response = requests.get(f"{BASE_URL}/health")
    print(f"Статус: {response.status_code}")
    print(f"Ответ: {json.dumps(response.json(), indent=2, ensure_ascii=False)}\n")

def test_chunks_only():
    """Тест разбиения на чанки без эмбеддингов"""
    print("=== Тест /chunks-only ===")
    
    payload = {
        "text": test_text,
        "chunk_size": 200,
        "overlap": 50
    }
    
    response = requests.post(f"{BASE_URL}/chunks-only", json=payload)
    print(f"Статус: {response.status_code}")
    
    if response.status_code == 200:
        data = response.json()
        print(f"Всего чанков: {data['total_chunks']}")
        print(f"Длина оригинального текста: {data['original_length']}\n")
        
        for chunk in data['chunks']:
            print(f"Чанк {chunk['chunk_id']}:")
            print(f"  Длина: {chunk['length']} символов")
            print(f"  Позиция: {chunk['start_pos']}-{chunk['end_pos']}")
            print(f"  Текст: {chunk['text'][:100]}...\n")
    else:
        print(f"Ошибка: {response.text}\n")

def test_process():
    """Тест полной обработки с эмбеддингами"""
    print("=== Тест /process (с эмбеддингами) ===")
    
    # Используем короткий текст для теста
    short_text = "Это короткий тестовый текст.\n\nОн состоит из двух абзацев."
    
    payload = {
        "text": short_text,
        "chunk_size": 100,
        "overlap": 20,
        "title": "Тестовый документ"
    }
    
    response = requests.post(f"{BASE_URL}/process", json=payload)
    print(f"Статус: {response.status_code}")
    
    if response.status_code == 200:
        data = response.json()
        print(f"Всего чанков: {data['total_chunks']}")
        print(f"Размерность эмбеддинга: {data['dimension']}")
        print(f"Длина оригинала: {data['original_length']}\n")
        
        for chunk in data['chunks']:
            print(f"Чанк {chunk['chunk_id']}:")
            print(f"  Текст: {chunk['text'][:80]}...")
            print(f"  Первые 5 значений эмбеддинга: {chunk['embedding'][:5]}")
            print(f"  Позиция: {chunk['start_pos']}-{chunk['end_pos']}\n")
    else:
        print(f"Ошибка: {response.text}\n")

def test_custom_text():
    """Тест с твоим текстом"""
    print("=== Тест с пользовательским текстом ===")
    
    custom_text = """Тема: Работа с файлами 
Открытие и закрытие файлов 
Python поддерживает множество различных типов файлов, но условно их можно 
разделить на два виде: текстовые и бинарные. Текстовые файлы - это к примеру файлы с 
расширением cvs, txt, html, в общем любые файлы, которые сохраняют информацию в 
текстовом виде. Бинарные файлы - это изображения, аудио и видеофайлы и т.д. В 
зависимости от типа файла работа с ним может немного отличаться. 
При работе с файлами необходимо соблюдать некоторую последовательность 
операций: 
1. Открытие файла с помощью метода open() 
2. Чтение файла с помощью метода read() или запись в файл посредством 
метода write() 
3. Закрытие файла методом close() 
Открытие и закрытие файла 
Чтобы начать работу с файлом, его надо открыть с помощью функции open(), 
которая имеет следующее формальное определение: 
open(file, mode) 
Первый параметр функции представляет путь к файлу. Путь файла может быть 
абсолютным, то есть начинаться с буквы диска, например, C://somedir/somefile.txt. Либо 
можно быть относительным, например, somedir/somefile.txt - в этом случае поиск файла 
будет идти относительно расположения запущенного скрипта Python. 
Второй передаваемый аргумент - mode устанавливает режим открытия файла в 
зависимости от того, что мы собираемся с ним делать. Существует 4 общих режима: 
• r (Read). Файл открывается для чтения. Если файл не найден, то генерируется 
исключение FileNotFoundError 
• w (Write). Файл открывается для записи. Если файл отсутствует, то он создается. 
Если подобный файл уже есть, то он создается заново, и соответственно старые 
данные в нем стираются. 
• a (Append). Файл открывается для дозаписи. Если файл отсутствует, то он 
создается. Если подобный файл уже есть, то данные записываются в его конец. 
• b (Binary). Используется для работы с бинарными файлами. Применяется вместе с 
другими режимами - w или r. 
После завершения работы с файлом его обязательно нужно закрыть методом close(). 
Данный метод освободит все связанные с файлом используемые ресурсы. 
Например, откроем для записи текстовый файл "hello.txt": 
myfile = open("hello.txt", "w") 
myfile.close() 
При открытии файла или в процессе работы с ним мы можем столкнуться с 
различными исключениями, например, к нему нет доступа и т.д. В этом случае программа 
выпадет в ошибку, а ее выполнение не дойдет до вызова метода close, и соответственно 
файл не будет закрыт. 
В этом случае мы можем обрабатывать исключения: 
try: 
somefile = open("hello.txt", "w") 
try: 
somefile.write("hello world") 
except Exception as e: 
print(e) 
finally: 
somefile.close() 
except Exception as ex: 
print(ex) 
В данном случае вся работа с файлом идет во вложенном блоке try. И если вдруг 
возникнет какое-либо исключение, то в любом случае в блоке finally файл будет закрыт. 
Однако есть и более удобная конструкция - конструкция with: 
with open(file, mode) as file_obj: 
инструкции 
Эта конструкция определяет для открытого файла переменную file_obj и выполняет 
набор инструкций. После их выполнения файл автоматически закрывается. Даже если при 
выполнении инструкций в блоке with возникнут какие-либо исключения, то файл все равно 
закрывается. 
Так, перепишем предыдущий пример: 
with open("hello.txt", "w") as somefile: 
somefile.write("hello world") 
Текстовые файлы 
Запись в текстовый файл 
Чтобы открыть текстовый файл на запись, необходимо применить режим w 
(перезапись) или a (дозапись). Затем для записи применяется метод write(str), в который 
передается записываемая строка. Стоит отметить, что записывается именно строка, 
поэтому, если нужно записать числа, данные других типов, то их предварительно нужно 
конвертировать в строку. 
Запишем некоторую информацию в файл "hello.txt": 
with open("hello.txt", "w") as file: 
file.write("hello world") 
Если мы откроем папку, в которой находится текущий скрипт Python, то увидим там 
файл hello.txt. Этот файл можно открыть в любом текстовом редакторе и при желании 
изменить. 
Теперь дозапишем в этот файл еще одну строку: 
with open("hello.txt", "a") as file: 
file.write("\ngood bye, world") 
Дозапись выглядит как добавление строку к последнему символу в файле, поэтому, 
если необходимо сделать запись с новой строки, то можно использовать эскейп
последовательность "\n". В итоге файл hello.txt будет иметь следующее содержимое: 
hello world 
good bye, world 
Еще один способ записи в файл представляет стандартный метод print(), который 
применяется для вывода данных на консоль: 
with open("hello.txt", "a") as hello_file: 
print("Hello, world", file=hello_file) 
Для вывода данных в файл в метод print в качестве второго параметра передается 
название файла через параметр file. А первый параметр представляет записываемую в файл 
строку. 
Чтение файла 
Для чтения файла он открывается с режимом r (Read), и затем мы можем считать его 
содержимое различными методами: 
• readline(): считывает одну строку из файла 
• read(): считывает все содержимое файла в одну строку 
• readlines(): считывает все строки файла в список 
Например, считаем выше записанный файл построчно: 
with open("hello.txt", "r") as file: 
for line in file: 
print(line, end="") 
Несмотря на то, что мы явно не применяем метод readline() для чтения каждой 
строки, но в при переборе файла этот метод автоматически вызывается для получения 
каждой новой строки. Поэтому в цикле вручную нет смысла вызывать метод readline. И 
поскольку строки разделяются символом перевода строки "\n", то чтобы исключить 
излишнего переноса на другую строку в функцию print передается значение end="". 
Теперь явным образом вызовем метод readline() для чтения отдельных строк: 
with open("hello.txt", "r") as file: 
str1 = file.readline() 
print(str1, end="") 
str2 = file.readline() 
print(str2) 
Консольный вывод: 
hello world 
good bye, world 
Метод readline можно использовать для построчного считывания файла в цикле while: 
with open("hello.txt", "r") as file: 
line = file.readline() 
while line: 
print(line, end="") 
line = file.readline() 
Если файл небольшой, то его можно разом считать с помощью метода read(): 
with open("hello.txt", "r") as file: 
content = file.read() 
print(content) 
И также применим метод readlines() для считывания всего файла в список строк: 
with open("hello.txt", "r") as file: 
contents = file.readlines() 
str1 = contents[0] 
str2 = contents[1] 
print(str1, end="") 
print(str2) 
При чтении файла мы можем столкнуться с тем, что его кодировка не совпадает с 
ASCII. В этом случае мы явным образом можем указать кодировку с помощью 
параметра encoding: 
filename = "hello.txt" 
with open(filename, encoding="utf8") as file: 
text = file.read() 
Теперь напишем небольшой скрипт, в котором будет записывать введенный 
пользователем массив строк и считывать его обратно из файла на консоль: 
# имя файла 
FILENAME = "messages.txt" 
# определяем пустой список 
messages = list() 
for i in range(4): 
message = input("Введите строку " + str(i+1) + ": ") 
messages.append(message + "\n") 
# запись списка в файл 
with open(FILENAME, "a") as file: 
for message in messages: 
file.write(message) 
# считываем сообщения из файла 
print("Считанные сообщения") 
with open(FILENAME, "r") as file: 
for message in file: 
print(message, end="") 
Пример работы программы: 
Введите строку 1: hello 
Введите строку 2: world peace 
Введите строку 3: great job 
Введите строку 4: Python 
Считанные сообщения 
hello 
world peace 
great job 
Python """
    
    if not custom_text.strip():
        print("Пропущено.\n")
        return
    
    payload = {
        "text": custom_text
    }
    
    response = requests.post(f"{BASE_URL}/chunks-only", json=payload)
    
    if response.status_code == 200:
        data = response.json()
        print(f"Создано чанков: {data['total_chunks']}\n")
        for chunk in data['chunks']:
            print(f"Чанк {chunk['chunk_id']}: {chunk['text']}\n")
    else:
        print(f"Ошибка: {response.text}\n")

if __name__ == "__main__":
    print("Начинаем тестирование API...\n")
    
    try:
        # 1. Проверка здоровья
        test_health()
        
        # 2. Тест разбиения на чанки
        test_chunks_only()
        
        # 3. Тест с эмбеддингами (требует GEMINI_API_KEY)
        proceed = input("Хочешь протестировать /process с эмбеддингами? (требует API ключ) [y/n]: ")
        if proceed.lower() == 'y':
            test_process()
        
        # 4. Тест с твоим текстом
        test_custom_text()
        
        print("✅ Тестирование завершено!")
        
    except requests.exceptions.ConnectionError:
        print("❌ Не удалось подключиться к API. Убедись, что сервер запущен на http://localhost:8000")
    except Exception as e:
        print(f"❌ Ошибка: {e}")